#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Wed Aug 10 17:57:29 2022@author: ak"""import numpy as npimport matplotlib.pyplot as plt"""Below is a Geometric Brownian Motion for  calculating stock price (lognormal behavior):    dS(t) = mu*S(t)*dt + sigma*S(t)*dW(t)    This is equivalent to following Arthematic Brownian Motion:    dX(t) = (mu - 0.5*sigma^2)*dt + sigma*dW(t)    where X(t) = log(S(t))    Discretized version of the above equations is:    X(t+dT) = X(t) + (mu - 0.5*sigma^2)*dt + sigma*(W(t)*(dt)^0.5)    Below we are using (risk free interest) rate as mu, S_0 as initial stock price.At the end, we plot all the paths, calculate expected value of the stock price.Expected stock price discounted using risk free rate. We confirm that stock pricediscounted with risk free rate is martingale."""def Generate_GBM_ABM_Paths(nPaths, nSteps, totalTime, rate, sigma, S_0):        #fixing random seed    np.random.seed(1)        W = np.random.normal(0.0, 1.0, [nPaths, nSteps])    X = np.zeros([nPaths, nSteps+1])    S = np.zeros([nPaths, nSteps+1])    time = np.zeros([nSteps+1])        X[:,0] = np.log(S_0)    dt = totalTime / float(nSteps)    sqrt_dt = np.power(dt, 0.5)    sigmaSqBy2 = 0.5*sigma*sigma        for i in range(0, nSteps):        if nPaths > 1:            W[:,i] = (W[:,i] - np.mean(W[:,i])) / np.std(W[:,i])                    X[:,i+1] = X[:,i] + (rate - sigmaSqBy2)*dt +sigma*sqrt_dt*W[:,i]        time[i+1] = time[i] + dt            S = np.exp(X)    paths = {"time":time, "X":X, "S":S}        return pathsdef Calculate_Paths_And_Plot():    nPaths = 25    nSteps = 500    totalTime = 1    rate = 0.05    sigma = 0.4    S_0 = 100        Paths = Generate_GBM_ABM_Paths(nPaths, nSteps, totalTime, rate, sigma, S_0)    timeAxis = Paths["time"]    X = Paths["X"]    S = Paths["S"]        plt.figure(1)    plt.plot(timeAxis, np.transpose(X))       plt.grid()    plt.xlabel("time")    plt.ylabel("X(t)")        plt.figure(2)    plt.plot(timeAxis, np.transpose(S))       plt.grid()    plt.xlabel("time")    plt.ylabel("S(t)")        # checking martingale property    exVal_S = np.mean(S[:,-1])    print("Expected value of the stock price is: ", exVal_S)        discountFactor = lambda rate, time: np.exp(rate * time)    exVal_S_Martingale = np.mean(S[:,-1]/discountFactor(rate, totalTime))    print("Expected stock price discounted by risk free interest rate: ", exVal_S_Martingale)    Calculate_Paths_And_Plot()    